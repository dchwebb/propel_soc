// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2020 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE 
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR 
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL 
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE 
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.  
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------

#define	__timer_t_defined
#include "utils.h"
#include "pic.h"

typedef struct
{
  volatile uint32_t RD_DATA;         // Address offset: 0x00
  volatile uint32_t WR_DATA;         // Address offset: 0x04
  volatile uint32_t SET_DATA;        // Address offset: 0x08
  volatile uint32_t CLEAR_DATA;      // Address offset: 0x0C
  volatile uint32_t DIRECTION;       // Address offset: 0x10
  volatile uint32_t INT_TYPE;        // Address offset: 0x14
  volatile uint32_t INT_METHOD;      // Address offset: 0x18
  volatile uint32_t INT_STATUS;      // Address offset: 0x1C
  volatile uint32_t INT_ENABLE;      // Address offset: 0x20
  volatile uint32_t INT_SET;         // Address offset: 0x24
} GPIO_TypeDef;
#define GPIO0                ((GPIO_TypeDef *) GPIO0_INST_BASE_ADDR)

uint8_t interrupt;

void gpio_interrupt_handler(void* context) {
	interrupt++;
	GPIO0->INT_STATUS = 0x80;		// Clear the interrupt on the GPIO peripheral
}

int main(void) {
	uint8_t result = pic_init(CPU0_INST_PICTIMER_START_ADDR);
	//result = pic_int_enable(GPIO0_INST_IRQ);
	// Register IRQ handler for GPIO interrupts (this also enables the interrupt)
	pic_isr_register(GPIO0_INST_IRQ, gpio_interrupt_handler, GPIO0);

	static uint8_t idx = 0;
	uint8_t input = 0;
	interrupt = 0;

	DEBUG_PRINTF("Hello RISC-V world!\r\n");

	// set direction of LEDs to all out except for last one which is in
	GPIO0->DIRECTION = 0x7F;

	// Interrupt on GPIO 7 high
	GPIO0->INT_ENABLE = 0x80;
	GPIO0->INT_TYPE = 0x00;			// 0 = Edge, 1 = Level
	GPIO0->INT_METHOD = 0x80;		// 1 = Rising edge


	LED_SET(ALL_OFF);

	while (true) {
		input = GPIO0->RD_DATA & (1 << 7);

		// Increment on each interrupt
//		if (GPIO0->INT_STATUS & (1 << 7)) {
//			interrupt++;
//			GPIO0->INT_STATUS = 0x80;
//		}

		if (idx == 0) {
			uartPutS("Blinking\n\r");
		}
		LED_SET(LED_ON(idx));

		if (++idx == 7) {
			idx = 0;
		}

		if (RTL_SIM) {
			delayMS(1);
		} else {
			delayMS(100);
		}
	}

	return 0;
}

